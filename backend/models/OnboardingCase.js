const mongoose = require('mongoose');

const historyEntrySchema = new mongoose.Schema({
  action: {
    type: String,
    required: true,
    enum: [
      'created', 'submitted', 'document_uploaded', 'document_verified',
      'ocr_completed', 'nlp_analysis_completed', 'sanctions_check_completed',
      'risk_score_updated', 'assigned', 'reassigned', 'comment_added',
      'approval_requested', 'approved', 'rejected', 'returned_for_info',
      'escalated', 'completed', 'expired', 'cancelled', 'reactivated',
      'field_updated', 'status_changed', 'verification_completed',
      'manual_override', 'auto_approved', 'sla_warning', 'sla_breach'
    ]
  },
  description: String,
  performedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  performedByType: {
    type: String,
    enum: ['user', 'system', 'vendor', 'api'],
    default: 'user'
  },
  metadata: mongoose.Schema.Types.Mixed,
  timestamp: {
    type: Date,
    default: Date.now
  }
}, { _id: true });

const taskSchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    enum: [
      'document_upload', 'document_review', 'data_verification',
      'sanctions_check', 'identity_verification', 'bank_verification',
      'compliance_review', 'approval', 'contract_review', 'final_review'
    ]
  },
  title: {
    type: String,
    required: true
  },
  description: String,
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed', 'skipped', 'failed', 'blocked'],
    default: 'pending'
  },
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  assignedRole: String,
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  dueDate: Date,
  completedAt: Date,
  completedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  result: mongoose.Schema.Types.Mixed,
  automatable: {
    type: Boolean,
    default: false
  },
  automated: {
    type: Boolean,
    default: false
  },
  blockedBy: [{
    type: mongoose.Schema.Types.ObjectId
  }],
  order: {
    type: Number,
    default: 0
  }
}, { _id: true });

const onboardingCaseSchema = new mongoose.Schema({
  // Case Reference
  caseNumber: {
    type: String,
    unique: true,
    required: false  // Generated by pre-save hook
  },
  
  // Vendor Profile
  vendorProfile: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'VendorProfile',
    required: true
  },
  
  // Onboarding Type
  type: {
    type: String,
    enum: ['new_vendor', 'reactivation', 'update', 'merger', 'acquisition'],
    default: 'new_vendor'
  },
  
  // Source/Channel
  source: {
    type: String,
    enum: ['self_service', 'invite', 'bulk_upload', 'email', 'api', 'internal'],
    default: 'self_service'
  },
  invitedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  inviteToken: String,
  inviteExpiresAt: Date,
  
  // Status & Progress
  status: {
    type: String,
    enum: [
      'draft', 'pending_submission', 'submitted', 'in_review',
      'pending_documents', 'pending_verification', 'pending_approval',
      'approved', 'rejected', 'on_hold', 'cancelled', 'expired'
    ],
    default: 'draft'
  },
  progressPercentage: {
    type: Number,
    min: 0,
    max: 100,
    default: 0
  },
  currentStep: {
    type: String,
    default: 'basic_info'
  },
  
  // Assignment
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  assignedTeam: String,
  
  // Tasks
  tasks: [taskSchema],
  
  // Risk Assessment
  riskTier: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  riskScores: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'RiskScore'
  }],
  autoApprovalEligible: {
    type: Boolean,
    default: false
  },
  
  // Verification Results
  verificationResults: {
    sanctions: {
      status: { type: String, enum: ['pending', 'clear', 'flagged', 'error'] },
      checkedAt: Date,
      provider: String,
      hits: [mongoose.Schema.Types.Mixed]
    },
    businessRegistry: {
      status: { type: String, enum: ['pending', 'verified', 'mismatch', 'not_found', 'error'] },
      checkedAt: Date,
      provider: String,
      data: mongoose.Schema.Types.Mixed
    },
    bankAccount: {
      status: { type: String, enum: ['pending', 'verified', 'failed', 'error'] },
      verifiedAt: Date,
      method: String
    },
    identity: {
      status: { type: String, enum: ['pending', 'verified', 'failed', 'error'] },
      verifiedAt: Date,
      method: String
    }
  },
  
  // Documents
  documents: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Document'
  }],
  requiredDocuments: [{
    type: {
      type: String,
      required: true
    },
    name: String,
    required: Boolean,
    uploaded: Boolean,
    documentId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Document'
    }
  }],
  
  // Approvals
  approvalMatrix: [{
    role: String,
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    required: Boolean,
    order: Number,
    status: {
      type: String,
      enum: ['pending', 'approved', 'rejected', 'skipped'],
      default: 'pending'
    },
    decidedAt: Date,
    comments: String
  }],
  
  // Final Decision
  finalDecision: {
    decision: {
      type: String,
      enum: ['approved', 'rejected', 'conditional']
    },
    decidedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    decidedAt: Date,
    reason: String,
    conditions: [String]
  },
  
  // SLA & Timing
  sla: {
    targetCompletionDate: Date,
    warningDate: Date,
    breachDate: Date,
    breached: { type: Boolean, default: false },
    pausedAt: Date,
    totalPausedDuration: { type: Number, default: 0 } // in milliseconds
  },
  
  // Timestamps
  submittedAt: Date,
  firstReviewAt: Date,
  completedAt: Date,
  
  // History / Audit Trail
  history: [historyEntrySchema],
  
  // Evidence Bundle
  evidenceBundle: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'EvidenceBundle'
  },
  
  // Metadata
  metadata: mongoose.Schema.Types.Mixed,
  tags: [String],
  
  // Internal Notes
  internalNotes: [{
    note: String,
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    createdAt: {
      type: Date,
      default: Date.now
    },
    isPrivate: {
      type: Boolean,
      default: false
    }
  }],
  
  // Vendor Communication
  vendorMessages: [{
    message: String,
    sentBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    sentByType: {
      type: String,
      enum: ['internal', 'vendor', 'system']
    },
    sentAt: {
      type: Date,
      default: Date.now
    },
    read: {
      type: Boolean,
      default: false
    }
  }],
  
  // Audit
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
onboardingCaseSchema.index({ caseNumber: 1 });
onboardingCaseSchema.index({ status: 1 });
onboardingCaseSchema.index({ vendorProfile: 1 });
onboardingCaseSchema.index({ assignedTo: 1, status: 1 });
onboardingCaseSchema.index({ riskTier: 1, status: 1 });
onboardingCaseSchema.index({ 'sla.targetCompletionDate': 1 });
onboardingCaseSchema.index({ createdAt: -1 });
onboardingCaseSchema.index({ inviteToken: 1 }, { sparse: true });

// Virtual for days in current status
onboardingCaseSchema.virtual('daysInStatus').get(function() {
  const lastStatusChange = this.history
    .filter(h => h.action === 'status_changed')
    .sort((a, b) => b.timestamp - a.timestamp)[0];
  
  const startDate = lastStatusChange?.timestamp || this.createdAt;
  return Math.floor((Date.now() - startDate) / (1000 * 60 * 60 * 24));
});

// Virtual for total processing time
onboardingCaseSchema.virtual('totalProcessingTime').get(function() {
  if (!this.submittedAt) return null;
  const endDate = this.completedAt || new Date();
  const totalTime = endDate - this.submittedAt - this.sla.totalPausedDuration;
  return Math.floor(totalTime / (1000 * 60 * 60 * 24)); // days
});

// Static method to generate case number
onboardingCaseSchema.statics.generateCaseNumber = async function() {
  const date = new Date();
  const year = date.getFullYear().toString().slice(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  
  const lastCase = await this.findOne({
    caseNumber: new RegExp(`^ONB-${year}${month}`)
  }).sort({ caseNumber: -1 });
  
  let sequence = 1;
  if (lastCase) {
    const lastSequence = parseInt(lastCase.caseNumber.split('-')[2]);
    sequence = lastSequence + 1;
  }
  
  return `ONB-${year}${month}-${sequence.toString().padStart(5, '0')}`;
};

// Method to add history entry
onboardingCaseSchema.methods.addHistory = function(action, description, performedBy, performedByType = 'user', metadata = {}) {
  this.history.push({
    action,
    description,
    performedBy,
    performedByType,
    metadata,
    timestamp: new Date()
  });
};

// Method to calculate progress
onboardingCaseSchema.methods.calculateProgress = function() {
  if (!this.tasks || this.tasks.length === 0) return 0;
  
  const completedTasks = this.tasks.filter(t => 
    t.status === 'completed' || t.status === 'skipped'
  ).length;
  
  this.progressPercentage = Math.round((completedTasks / this.tasks.length) * 100);
  return this.progressPercentage;
};

// Method to check SLA status
onboardingCaseSchema.methods.checkSlaStatus = function() {
  const now = new Date();
  
  if (this.sla.breachDate && now > this.sla.breachDate) {
    this.sla.breached = true;
    return 'breached';
  }
  
  if (this.sla.warningDate && now > this.sla.warningDate) {
    return 'warning';
  }
  
  return 'on_track';
};

// Pre-save hook
onboardingCaseSchema.pre('save', async function(next) {
  if (this.isNew && !this.caseNumber) {
    this.caseNumber = await this.constructor.generateCaseNumber();
  }
  this.calculateProgress();
  next();
});

module.exports = mongoose.model('OnboardingCase', onboardingCaseSchema);
